import BigNumber from 'bignumber.js'
import erc20 from 'src/abis/IERC20'
import stableToken from 'src/abis/StableToken'
import { showError } from 'src/alert/actions'
import { TransactionEvents } from 'src/analytics/Events'
import ValoraAnalytics from 'src/analytics/ValoraAnalytics'
import { ErrorMessages } from 'src/app/ErrorMessages'
import { encryptComment } from 'src/identity/commentEncryption'
import { getTokenInfo, tokenAmountInSmallestUnit } from 'src/tokens/saga'
import {
  fetchTokenBalances,
  tokenBalanceHasAddress,
  TokenBalanceWithAddress,
} from 'src/tokens/slice'
import { tokenSupportsComments } from 'src/tokens/utils'
import {
  addHashToStandbyTransaction,
  addStandbyTransaction,
  removeStandbyTransaction,
  transactionConfirmed,
} from 'src/transactions/actions'
import { wrapSendTransactionWithRetry } from 'src/transactions/send'
import { Network, TokenTransactionTypeV2, TransactionContext } from 'src/transactions/types'
import Logger from 'src/utils/Logger'
import { ensureError } from 'src/utils/ensureError'
import { publicClient } from 'src/viem'
import { ViemWallet } from 'src/viem/getLockableWallet'
import { getViemWallet } from 'src/web3/contracts'
import networkConfig from 'src/web3/networkConfig'
import { unlockAccount } from 'src/web3/saga'
import { getNetworkFromNetworkId } from 'src/web3/utils'
import { call, put } from 'typed-redux-saga'
import { getAddress, SimulateContractReturnType, TransactionReceipt } from 'viem'
import {
  getPreparedTransaction,
  SerializableTransactionRequestCIP42,
} from 'src/viem/preparedTransactionSerialization'
import { TransactionRequestCIP42 } from 'node_modules/viem/_types/chains/celo/types'

const TAG = 'viem/saga'

/**
 * Send a payment with viem. The equivalent of buildAndSendPayment in src/send/saga.
 *
 * @param options an object containing the arguments
 * @param options.context the transaction context
 * @param options.recipientAddress the address to send the payment to
 * @param options.amount the crypto amount to send
 * @param options.tokenId the crypto token id
 * @param options.comment the comment on the transaction
 * @returns
 */
export function* sendPayment({
  context,
  recipientAddress,
  amount,
  tokenId,
  comment,
  preparedTransaction,
}: {
  context: TransactionContext
  recipientAddress: string
  amount: BigNumber
  tokenId: string
  comment: string
  preparedTransaction?: SerializableTransactionRequestCIP42
}) {
  const tokenInfo = yield* call(getTokenInfo, tokenId)
  const network = getNetworkFromNetworkId(tokenInfo?.networkId)
  if (!tokenInfo || !network) {
    throw new Error('Unknown token network')
  }

  const wallet = yield* call(getViemWallet, networkConfig.viemChain[network])

  if (!wallet.account) {
    // this should never happen
    throw new Error('no account found in the wallet')
  }

  Logger.debug(
    TAG,
    'Transferring token',
    context.description ?? 'No description',
    context.id,
    tokenId,
    amount,
    preparedTransaction
  )

  const unlockAndAddStandby = function* () {
    // This will never happen, but Typescript complains otherwise
    if (!wallet.account) {
      throw new Error('no account found in the wallet')
    }

    // unlock account before executing tx
    yield* call(unlockAccount, wallet.account.address)

    yield* put(
      addStandbyTransaction({
        __typename: 'TokenTransferV3',
        type: TokenTransactionTypeV2.Sent,
        context,
        networkId: tokenInfo.networkId,
        amount: {
          value: amount.negated().toString(),
          tokenAddress: tokenInfo.address ?? undefined,
          tokenId,
        },
        address: recipientAddress,
        metadata: {
          comment,
        },
      })
    )
  }

  // For tokens with an address, we simulate calling 'transfer' on the contract,
  // take the request generated by that simulation, and execute that request
  //
  // For tokens with no address, we perform a simple `call` to test the request.
  try {
    if (tokenBalanceHasAddress(tokenInfo)) {
      // this returns a method which is then passed to call instead of directly
      // doing yield* call(publicClient.celo.simulateContract, args) because this
      // results in a long TS error
      const simulateContractMethod = yield* call(getTransferSimulateContract, {
        wallet,
        tokenInfo,
        amount,
        recipientAddress,
        comment,
        preparedTransaction,
      })

      const { request } = yield* call(simulateContractMethod)
      yield* call(unlockAndAddStandby)

      const sendContractTxMethod = () =>
        wallet.writeContract(request as SimulateContractReturnType['request'])

      const receipt = yield* call(sendAndMonitorTransaction, {
        context,
        network,
        sendTx: sendContractTxMethod,
      })

      return receipt
    } else {
      const convertedAmount = BigInt(tokenAmountInSmallestUnit(amount, tokenInfo.decimals))

      // This call method will throw an error if there are issues with the TX (namely,
      // if there are insufficient funds to pay for gas).
      const callMethod = () =>
        publicClient[network].call({
          account: wallet.account,
          to: getAddress(recipientAddress),
          value: convertedAmount,
        })

      yield* call(callMethod)
      yield* call(unlockAndAddStandby)

      const sendNativeTxMethod = () => {
        if (!wallet.account) {
          throw new Error('no account found in the wallet')
        }
        return wallet.sendTransaction({
          account: wallet.account,
          to: getAddress(recipientAddress),
          value: convertedAmount,
          chain: networkConfig.viemChain[network],
        })
      }

      const receipt = yield* call(sendAndMonitorTransaction, {
        context,
        network,
        sendTx: sendNativeTxMethod,
      })
      return receipt
    }
  } catch (err) {
    Logger.error(TAG, JSON.stringify(err, null, 4))
    Logger.warn(TAG, 'Transaction failed', err)
    throw err
  }
}

/**
 * Gets a function that invokes simulateContract for the appropriate contract
 * method based on the token. If the token is a stable token, it uses the
 * `transferWithComment` on the stable token contract, otherwise the `transfer`
 * method on the ERC20 contract
 *
 * @param options an object containing the arguments
 * @returns a function that invokes the simulateContract method
 */
function* getTransferSimulateContract({
  wallet,
  tokenInfo,
  amount,
  recipientAddress,
  comment,
  preparedTransaction,
}: {
  wallet: ViemWallet
  tokenInfo: TokenBalanceWithAddress
  recipientAddress: string
  amount: BigNumber
  comment: string
  preparedTransaction?: SerializableTransactionRequestCIP42
}) {
  if (!wallet.account) {
    // this should never happen
    throw new Error('no account found in the wallet')
  }

  const convertedAmount = BigInt(tokenAmountInSmallestUnit(amount, tokenInfo.decimals))

  const encryptedComment = tokenSupportsComments(tokenInfo)
    ? yield* call(encryptComment, comment, recipientAddress, wallet.account.address, true)
    : undefined

  const network = getNetworkFromNetworkId(tokenInfo.networkId)
  if (!network) {
    throw new Error('invalid network for transfer')
  }

  // TODO (ACT-922): Remove this check once fee info is available for all sends
  if (!preparedTransaction && network === Network.Celo) {
    throw new Error('Celo sends must include fee info')
  }

  // TODO (ACT-922): Use real fee estimation for Ethereum
  let feeFields: Pick<TransactionRequestCIP42, 'gas' | 'maxFeePerGas'> & { feeCurrency?: string } =
    {
      gas: undefined,
      maxFeePerGas: undefined,
    }
  if (preparedTransaction) {
    const preparedTx = getPreparedTransaction(preparedTransaction)
    feeFields = {
      gas: preparedTx.gas,
      maxFeePerGas: preparedTx.maxFeePerGas,
    }
    if (preparedTx.feeCurrency) {
      feeFields.feeCurrency = preparedTx.feeCurrency
    }
  }

  if (tokenSupportsComments(tokenInfo)) {
    Logger.debug(TAG, 'Calling simulate contract for transferWithComment with new fee fields', {
      recipientAddress,
      convertedAmount,
      feeCurrency: feeFields.feeCurrency,
      gas: feeFields.gas?.toString(),
      maxFeePerGas: feeFields.maxFeePerGas?.toString(),
    })

    return () =>
      publicClient.celo.simulateContract({
        address: getAddress(tokenInfo.address),
        abi: stableToken.abi,
        functionName: 'transferWithComment',
        account: wallet.account,
        args: [getAddress(recipientAddress), convertedAmount, encryptedComment || ''],
        ...feeFields,
      })
  }

  Logger.debug(TAG, 'Calling simulate contract for transfer with new fee fields', {
    recipientAddress,
    convertedAmount,
    feeCurrency: feeFields.feeCurrency,
    gas: feeFields.gas?.toString(),
    maxFeePerGas: feeFields.maxFeePerGas?.toString(),
  })

  return () =>
    publicClient[network].simulateContract({
      address: getAddress(tokenInfo.address),
      abi: erc20.abi,
      functionName: 'transfer',
      account: wallet.account,
      args: [getAddress(recipientAddress), convertedAmount],
      ...feeFields,
    })
}

export function* sendAndMonitorTransaction({
  context,
  network,
  sendTx,
}: {
  context: TransactionContext
  network: Network
  sendTx: () => Promise<`0x${string}`>
}) {
  Logger.debug(TAG + '@sendAndMonitorTransaction', `Sending transaction with id: ${context.id}`)

  const commonTxAnalyticsProps = { txId: context.id, web3Library: 'viem' as const }

  ValoraAnalytics.track(TransactionEvents.transaction_start, {
    ...commonTxAnalyticsProps,
    description: context.description,
  })

  const sendTxMethod = function* () {
    const hash = yield* call(sendTx)
    ValoraAnalytics.track(TransactionEvents.transaction_hash_received, {
      ...commonTxAnalyticsProps,
      txHash: hash,
    })

    yield* put(addHashToStandbyTransaction(context.id, hash))
    const receipt = yield* call([publicClient[network], 'waitForTransactionReceipt'], { hash })

    ValoraAnalytics.track(TransactionEvents.transaction_receipt_received, commonTxAnalyticsProps)
    return receipt as unknown as TransactionReceipt // Need to cast here else the wrapSendTransactionWithRetry call complains
  }

  try {
    // Reuse existing method which times out the sendTxMethod and includes some
    // grace period logic to handle app backgrounding when sending.
    // there is a bug with 'race' in typed-redux-saga, so we need to hard cast the result
    // https://github.com/agiledigital/typed-redux-saga/issues/43#issuecomment-1259706876
    const receipt = (yield* call(
      wrapSendTransactionWithRetry,
      sendTxMethod,
      context
    )) as unknown as TransactionReceipt

    if (receipt.status === 'reverted') {
      throw new Error('transaction reverted')
    }
    ValoraAnalytics.track(TransactionEvents.transaction_confirmed, commonTxAnalyticsProps)
    yield* put(
      transactionConfirmed(context.id, {
        transactionHash: receipt.transactionHash,
        block: receipt.blockNumber.toString(),
        status: receipt.status === 'success',
      })
    )
    yield* put(fetchTokenBalances({ showLoading: true }))
    return receipt
  } catch (err) {
    const error = ensureError(err)
    Logger.error(TAG + '@sendAndMonitorTransaction', `Error sending tx ${context.id}`, error)
    ValoraAnalytics.track(TransactionEvents.transaction_exception, {
      ...commonTxAnalyticsProps,
      error: error.message,
    })
    yield* put(removeStandbyTransaction(context.id))
    yield* put(showError(ErrorMessages.TRANSACTION_FAILED))
    throw error
  }
}
